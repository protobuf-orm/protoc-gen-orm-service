package app

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/protobuf-orm/protobuf-orm/graph"
	"github.com/protobuf-orm/protoc-gen-orm-service/internal/ast"
	"google.golang.org/protobuf/compiler/protogen"
)

type App struct {
	namer *template.Template

	// Generated file path -> Generated file.
	gfs map[string]*protogen.GeneratedFile
}

func New(opts ...Option) (*App, error) {
	a := &App{
		gfs: map[string]*protogen.GeneratedFile{},
	}
	for _, opt := range opts {
		opt(a)
	}
	if a.namer == nil {
		a.namer = template.Must(template.New("namer").Parse("{{ .Name }}_svc.g.proto"))
	}

	return a, nil
}

func (a *App) Run(ctx context.Context, p *protogen.Plugin, g *graph.Graph) error {
	ok := true
	handle_err := func(err error) {
		ok = false
	}

	w := newWork()
	for _, f := range p.Files {
		if !f.Generate {
			continue
		}

		gf, path, err := a.newGeneratedFile(p, f)
		if err != nil {
			handle_err(err)
			continue
		}

		var pf *ast.File
		for _, m := range f.Messages {
			entity, ok := g.Entities[m.Desc.FullName()]
			if !ok {
				continue
			}

			w.paths[string(entity.FullName())] = path

			pf = w.newFile(f, entity)
			if err := w.run(ctx, pf, entity); err != nil {
				handle_err(err)
				continue
			}
		}
		if pf == nil {
			// No entities in the file.
			gf.Skip()
			continue
		}

		pf.Imports = unique(pf.Imports)

		p := ast.NewPrinter(gf, pf.Package)
		pf.PrintTo(p)
	}
	if !ok {
		return errors.New("some tasks are failed")
	}

	return nil
}

func (a *App) newGeneratedFile(p *protogen.Plugin, f *protogen.File) (*protogen.GeneratedFile, string, error) {
	dir, name := filepath.Split(f.Desc.Path())
	name = strings.TrimSuffix(name, filepath.Ext(name))

	var b bytes.Buffer
	if err := a.namer.Execute(&b, struct{ Name string }{Name: name}); err != nil {
		return nil, "", fmt.Errorf("name %s: %w", f.GeneratedFilenamePrefix, err)
	}
	name = b.String()
	path := filepath.Join(dir, name)

	gf, ok := a.gfs[path]
	if ok {
		return gf, path, nil
	} else {
		gf = p.NewGeneratedFile(path, f.GoImportPath)
		a.gfs[path] = gf
	}

	gf.P(`// Code generated by protoc-gen-orm-service. DO NOT EDIT.`)
	gf.P(`// source: `, f.Desc.Path()+".proto")
	gf.P("")

	return gf, path, nil
}

func unique[T comparable](input []T) []T {
	seen := make(map[T]struct{})
	result := make([]T, 0, len(input))
	for _, v := range input {
		if _, ok := seen[v]; !ok {
			seen[v] = struct{}{}
			result = append(result, v)
		}
	}
	return result
}
